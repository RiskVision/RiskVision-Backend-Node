const axios = require('axios');

class VulnerabilityScanner {
    constructor(assets, interval = 6000, duration = 180000) {
        this.assets = assets;
        this.interval = interval;
        this.duration = duration;
        this.results = [];
        this.timer = null;
    }

    async start() {
        for (const asset of this.assets) {
            await this.scanAsset(asset);
            await this.sleep(1000); // Sleep to avoid rate limiting
        }
        return this.results;
    }

    async scanAsset(asset) {
        try {
            const vulnerabilities = [];

            /* // Primera búsqueda: marca y modelo
            const brandModelQuery = `${asset.marca} ${asset.modelo}`;
            console.log(`Scanning for brand and model: ${brandModelQuery}`);
            const responseBrandModel = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${brandModelQuery}&keywordExactMatch&pubStartDate=2024-09-04T00:00:00.000&pubEndDate=2024-11-09T00:00:00.000`);
            const filteredDataBrandModel = this.filterResponse(responseBrandModel.data);
            vulnerabilities.push(...filteredDataBrandModel);

            // Segunda búsqueda: sistema operativo y versión
            const osVersionQuery = `${asset.sistema_operativo} ${asset.version_so}`;
            console.log(`Scanning for OS and version: ${osVersionQuery}`);
            const responseOSVersion = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${osVersionQuery}&keywordExactMatch&pubStartDate=2024-09-04T00:00:00.000&pubEndDate=2024-11-09T00:00:00.000`);
            const filteredDataOSVersion = this.filterResponse(responseOSVersion.data);
            vulnerabilities.push(...filteredDataOSVersion); */

            // Tercera búsqueda: marca
            const brandQuery = `${asset.marca}`;
            console.log(`Scanning for brand and model: ${brandQuery}`);
            const responseBrand = await axios.get(`https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${brandQuery}&keywordExactMatch&pubStartDate=2024-09-04T00:00:00.000&pubEndDate=2024-11-09T00:00:00.000`);
            const filteredDataBrand = this.filterResponse(responseBrand.data);
            vulnerabilities.push(...filteredDataBrand);

            // Añadir las vulnerabilidades encontradas al activo
            asset['Vulnerabilidades encontradas'] = vulnerabilities;

            // Añadir el activo con las vulnerabilidades a los resultados
            this.results.push(asset);
        } catch (error) {
            console.error(`Error scanning ${asset.nombre_activo}:`, error);
        }
    }

    filterResponse(data) {
        const vulnerabilities = [];
        data.vulnerabilities.forEach(vuln => {
            const cve = vuln.cve;
            const processedVuln = {
                id: cve.id,
                published: cve.published,
                lastModified: cve.lastModified,
                description: cve.descriptions?.find(desc => desc.lang === 'en')?.value,
                cvssScore: cve.metrics?.cvssMetricV2?.[0]?.cvssData?.baseScore,
                vectorString: cve.metrics?.cvssMetricV2?.[0]?.cvssData?.vectorString,
                confidentialityImpact: cve.metrics?.cvssMetricV2?.[0]?.cvssData?.confidentialityImpact,
                integrityImpact: cve.metrics?.cvssMetricV2?.[0]?.cvssData?.integrityImpact,
                availabilityImpact: cve.metrics?.cvssMetricV2?.[0]?.cvssData?.availabilityImpact,
            };
            vulnerabilities.push(processedVuln);
        });
        return vulnerabilities;
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

module.exports = VulnerabilityScanner;